## 数据结构和算法基础


什么是数据结构和算法：`兵法`，计算的方法。
算法是独立存在的一种解决问题的方法和思想。


算法的特征：
- 输入：算法具有0个或多个输入
- 输出：算法至少有1个或多个输出
- 有穷性：算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成
- 确定性：算法中的每一步都有确定的含义，不会出现二义性
- 可行性：算法的每一步都是可行的，也就是说每一步都能执行有限的次数完成


> 时间复杂度和大O表示法


算法的优劣： 实现算法程序的**执行时间**可以反应出算法的效率

时间复杂度：步骤的执行速度(基本执行数量总和) + 程序运行环境（包括硬件和操作系统）

假设存在函数`g`，使得**算法A**处理规模为`n`的问题示例所用时间为`T(n)=O(g(n))`，则称`O(g(n))`为算法A的渐近时间复杂度，简称时间复杂度，记为`T(n)`
`T`: `time`
三个1000次`for`循环: 
`T = 1000 * 1000 * 1000 * 2` -> `T(n) = n ^ 3 * 2` -> `g(n) = n ^ 3`, `T(n) = k * g(n)` -> `T(n) = O(g(n))`


“大O记法”：对于单调的整数函数`f`，如果存在一个整数函数`g`和`实常数c>0`，使得对于充分大的`n`总有`f(n) <= c*g(n)`，就说函数`g`是`f`的一个**渐近函数（忽略常数）**，记为`f(n)=O(g(n))`。
也就是说，在趋向无穷的极限意义下，函数`f`的增长速度受到函数`g`的约束，亦即函数`f`与函数`g`的特征相似。


> 最坏时间复杂度

- 算法完成工作最少需要多少基本操作，即**最优时间复杂度**
- 算法完成工作最多需要多少基本操作，即**最坏时间复杂度**
- 算法完成工作平均需要多少基本操作，即**平均时间复杂度**

最优时间复杂度，其价值不大。
最坏时间复杂度，提供了一种保证，（只要关注，最坏时间复杂度）
平均时间复杂度，是对算法的一个全面评价。

> 时间复杂度的几条基本计算规则

- 基本步骤，即只有常数项，认为其时间复杂度为**O(1)**
- 顺序结构，时间复杂度按**加法**进行计算
- 循环结构，时间复杂度按**乘法**进行计算
- 分支结构，时间复杂度**取最大值**（`if` 或者 `else` 哪个步数最多）
- 判断一个算法的效率时，往往只需要关注**操作数量的最高次项**，其它次要项和常数项可以忽略
- 在没有特殊说明时，所分析的算法的时间复杂度都是指**最坏时间复杂度**

计算方式：
```
# for a in range(0, n):
#     for b in range(0, n):
#         c = 1000 - a - b
#         if a ** 2 + b ** 2 == c **2:
#             print('a, b, c为：%d'%(a, b, c))


# T(1000) = 1000 * 1000 * (1 + 1)
# T(n) = n * n * (1 + max(1, 0))
#  = n ^ 2 * 2
#  = O(n ^ 2)
```


> 常见时间复杂度与大小关系

|执行次数函数|阶|非正式术语|
|: ---:|: ---- :|: --- :|
|12	|O(1)|	常数阶|
|2n+3|	O(n)|	线性阶|
|3n2+2n+1|	O(n2)|	平方阶|
|5log2n+20	|O(logn)	|对数阶|
|2n+3nlog2n+19|	O(nlogn)|	nlogn阶|
|6n3+2n2+3n+4|	O(n3)	|立方阶|
|2n	| O(2n)|	指数阶|

note: 经常将`log2n`（以2为底的对数）简写成`logn`

所消耗的时间从小到大:
`O(1) < O(logn) < O(n) < O(nlogn) < O(n2) < O(n3) < O(2n) < O(n!) < O(nn)`




