## 数据结构和算法基础


什么是数据结构和算法：`兵法`，计算的方法。
算法是独立存在的一种解决问题的方法和思想。


算法的特征：
- 输入：算法具有0个或多个输入
- 输出：算法至少有1个或多个输出
- 有穷性：算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成
- 确定性：算法中的每一步都有确定的含义，不会出现二义性
- 可行性：算法的每一步都是可行的，也就是说每一步都能执行有限的次数完成


> 时间复杂度和大O表示法


算法的优劣： 实现算法程序的**执行时间**可以反应出算法的效率

时间复杂度：步骤的执行速度(基本执行数量总和) + 程序运行环境（包括硬件和操作系统）

假设存在函数`g`，使得**算法A**处理规模为`n`的问题示例所用时间为`T(n)=O(g(n))`，则称`O(g(n))`为算法A的渐近时间复杂度，简称时间复杂度，记为`T(n)`
`T`: `time`
三个1000次`for`循环: 
`T = 1000 * 1000 * 1000 * 2` -> `T(n) = n ^ 3 * 2` -> `g(n) = n ^ 3`, `T(n) = k * g(n)` -> `T(n) = O(g(n))`


“大O记法”：对于单调的整数函数`f`，如果存在一个整数函数`g`和`实常数c>0`，使得对于充分大的`n`总有`f(n) <= c*g(n)`，就说函数`g`是`f`的一个**渐近函数（忽略常数）**，记为`f(n)=O(g(n))`。
也就是说，在趋向无穷的极限意义下，函数`f`的增长速度受到函数`g`的约束，亦即函数`f`与函数`g`的特征相似。


> 最坏时间复杂度

- 算法完成工作最少需要多少基本操作，即**最优时间复杂度**
- 算法完成工作最多需要多少基本操作，即**最坏时间复杂度**
- 算法完成工作平均需要多少基本操作，即**平均时间复杂度**

最优时间复杂度，其价值不大。
最坏时间复杂度，提供了一种保证，（只要关注，最坏时间复杂度）
平均时间复杂度，是对算法的一个全面评价。

> 时间复杂度的几条基本计算规则

- 基本步骤，即只有常数项，认为其时间复杂度为**O(1)**
- 顺序结构，时间复杂度按**加法**进行计算
- 循环结构，时间复杂度按**乘法**进行计算
- 分支结构，时间复杂度**取最大值**（`if` 或者 `else` 哪个步数最多）
- 判断一个算法的效率时，往往只需要关注**操作数量的最高次项**，其它次要项和常数项可以忽略
- 在没有特殊说明时，所分析的算法的时间复杂度都是指**最坏时间复杂度**

计算方式：
```
# for a in range(0, n):
#     for b in range(0, n):
#         c = 1000 - a - b
#         if a ** 2 + b ** 2 == c **2:
#             print('a, b, c为：%d'%(a, b, c))


# T(1000) = 1000 * 1000 * (1 + 1)
# T(n) = n * n * (1 + max(1, 0))
#  = n ^ 2 * 2
#  = O(n ^ 2)
```


> 常见时间复杂度与大小关系

|执行次数函数|阶|非正式术语|
|: ---:|: ---- :|: --- :|
|12	|O(1)|	常数阶|
|2n+3|	O(n)|	线性阶|
|3n2+2n+1|	O(n2)|	平方阶|
|5log2n+20	|O(logn)	|对数阶|
|2n+3nlog2n+19|	O(nlogn)|	nlogn阶|
|6n3+2n2+3n+4|	O(n3)	|立方阶|
|2n	| O(2n)|	指数阶|

Note: 经常将`log2n`（以2为底的对数）简写成`logn`

![clipboard.png](/img/bV71Ql)

所消耗的时间从小到大:
`O(1) < O(logn) < O(n) < O(nlogn) < O(n2) < O(n3) < O(2n) < O(n!) < O(n^n)`

Note：函数是步骤和执行结构的综合

> Python内置类型性能

`timeit`模块作用：测试一小段`Python`代码代码的执行速度

`class timeit.Timer(stmt='pass', setup='pass', timer=<timer function>)`
`Timer`是测量小段代码执行速度的类。
`stmt`参数是要测试的代码语句（`statment`）；
`setup`参数是运行代码时需要的设置；
`timer`参数是一个定时器函数，与平台有关。

```
#coding=utf-8

from timeit import Timer


def test1():
    li = []
    for i in range(10000):
        li.append(i)

def test2():
    li = []
    for i in range(10000):
        li += [i]

def test3():
    li = [i for i in range(10000)]

def test4():
    li = list(range(10000))

timer1 = Timer('test1()', 'from __main__ import test1')
print('append: ',timer1.timeit(1000)) # 测算次数, 返回值测算时间

timer2 = Timer('test2()', 'from __main__ import test2')
print('+: ',timer1.timeit(1000))

timer3 = Timer('test3()', 'from __main__ import test3')
print('[]: ',timer1.timeit(1000))

timer4 = Timer('test4()', 'from __main__ import test4')
print('list: ',timer1.timeit(1000))
```

`list`内置操作的时间复杂度:

![clipboard.png](/img/bV72bw)

`n`: 列表长度
`k`: 范围

主要：
```
index[] -> O(1)
append -> O(1)
pop(i) -> O(n)
insert(i, item) -> O(n)
contains(in) -> O(n)
```

`dict`内置操作的时间复杂度:

![clipboard.png](/img/bV72cJ)


> 数据结构引入

算法关注在解决问题的步骤和思想上面。

什么是数据结构：数据的组织结构方式,（一组数据如何存储），基本数据类型（`int`， `float`，`char`）的封装


算法与数据结构的区别：
数据结构只是静态的描述了数据元素之间的关系。
高效的程序需要在数据结构的基础上设计和选择算法。

**程序 = 数据结构 + 算法**

总结：算法是为了解决实际问题而设计的，数据结构是算法需要处理的问题载体

最常用的数据运算有五种:

- 插入
- 删除
- 修改
- 查找
- 排序


## 顺序表

> 内存

32位机器：一个`int`, 占四个字节。

一个字节表示一个地址单元。

**变量**表示起始地址位置


> 类型本质

任何变量，函数原则上都是一块块大小各异的内存，而类型则是和系统对这块内存含义的**约定（固定内存块大小的别名）**

> 连续存储

顺序表的基本布局：

![clipboard.png](/img/bV77TX)


数据元素本身连续存储，每个元素所占的存储单元大小固定相同，元素的下标是其逻辑地址，而元素存储的物理地址（实际内存地址）可以通过存储区的起始地址Loc (e0)加上逻辑地址（第i个元素）与存储单元大小（c）的乘积计算而得

所以： 访问指定元素时无需从头遍历，通过计算便可获得对应地址，其时间复杂度为O(1)

下标：地址单元的偏移量，才会规定为从0开始。

顺序表的元素外置：

元素外置在内存中存储地址，地址字节是相同的（可以使用顺序表），而非变化的字节。


![clipboard.png](/img/bV77VI)
