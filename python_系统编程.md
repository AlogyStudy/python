
多任务：同一个时间段中，执行多个函数/运行多个程序.

操作系统可以同时运行多个任务:
操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，感觉就像所有任务都在同时执行一样。(时间片轮转)

任务 执行算法：
- 时间片轮转
- 优先级调度
- 调度算法（什么样的情况下按照什么样的规则，让哪个任务执行）

真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。 

- 进程
- 线程
- 协程

并发：看上去一齐执行（任务数>内核数）
并行：真正一齐执行（内核数>任务数）

程序：编写完毕的代码，在没有运行的时候（一个可执行的代码，可以理解称没有生命）
进程：正在运行的代码（除了包含代码外，还需要运行环境，占用的内存，键盘，显示器等，可以理解称具有生命）

## 进程

> 创建子进程

`os.fork()`创建新的进程，为子进程 

```
import os
import time

ret = os.fork() # 返回二个特殊值， 其中一个等于0（子进程），一个不固定的大于0的值（父进程，pid）。都是int类型。

if ret == 0:
    while True:
        print('1')
        time.sleep(1)
else:
    while True:
        print('2')
        time.sleep(1)
```

不一定父进程先执行，或子进程先执行，哪个进程先执行，是依靠操作系统调度算法。

> getpid、getppid

```
import os

ret = os.fork()
print(ret)
if ret > 0:
    print('父进程 - %d'%os.getpid())
else:
    print('子进程 - %d - %d'%(os.getpid(), os.getppid()))
    
"""
1535
父进程 - 1534
0
子进程 - 1535 - 1534
"""
```

`os.getpid()`: 子进程的pid的值
`os.getppid()`: 父进程的pid的值

父进程中`fork`的返回值，就是刚刚创建出来的子进程的`pid`

> 父子进程的先后顺序

主进程执行完结束后，子进程没有结束。照样主进程结束掉，而子进程一样执行完程序。

```
import os
import time

ret = os.fork()

if ret == 0:
    print('子进程')
    time.sleep(5)
    print('子进程over')
else:
    print('父进程')
    time.sleep(3)

print('over')
```
执行结果：
```
父进程
子进程
over
linxingzhangdeMacBook-Air:python linxingzhang$ 子进程over
over
光标定位到当前位置
```


 
