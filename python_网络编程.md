## 网络

> 网络通信

网络: 一种辅助双方或者多方能够连接在一起的工具

网络的目的：就是为了联通多方然后进行通信，即把数据从一方传递给另外一方。


使用网络能够把多方链接在一起，然后可以进行数据传递
网络编程： 让在不同的电脑上的软件能够进行数据传递，即**进程之间的通信**

> TCP/IP协议

TCP/IP协议(协议族)

为了把全世界的所有不同类型的计算机都连接起来，就必须规定一套全球通用的协议。
互联网协议簇(`Internet Protocol Suite`)就是通用协议标准。

因为互联网协议包含了上百种协议标准，但是最重要的两个协议是`TCP`和`IP`协议，所以把互联网协议简称为：`TCP/IP协议`


四层分类：`链路层` -> `网络层` -> `传输层` -> `应用层`
七层分类：`物理层` -> `数据链路层` -> `网络层` -> `传输层` -> `会话层` -> `表示层` -> `应用层`

![clipboard.png](/img/bV5luN)

网际层也称为：网络层
网络接口层也称为：链路层

> 端口

端口: 
- 操作系统为了**区分数据给哪个进程**，增加了一个标识**端口**。
- 进出进程的通道

`Pid`与`端口`: 同一台操作系统中，`pid`一定不同，而且可知，但是多台操作系统中，`Pid`不一定能够唯一, 不能够知道其它操作系统的进程的`pid`；而端口在多台操作系统中是唯一的。

端口作用：为了区分多个操作系统下具体是哪个进程。


端口号： 端口是通过端口号来标记的，端口号只有整数，范围是从**0到65535**(在`Linux`系统中，端口可以有**65536（2的16次方）**个。)

端口分类：
- 知名端口
    知名端口是众所周知的端口号，范围从0到1023: `80`端口分配给`HTTP`服务。`21`端口分配给`FTP`服务。`22`端口分配给`SSH`服务
- 动态端口
    动态端口的范围是从1024到65535。
    它一般不固定分配某种服务，而是动态分配。
    动态分配是指当一个系统进程或应用程序进程需要网络通信时，它向主机申请一个端口，主机从可用的端口号中分配一个供它使用。
    当这个进程关闭时，同时也就释放了所占用的端口号。

查看端口: `netstat -an`

> IP地址

地址: 用来标记地点的

`IP`地址的作用: 用来在网络中标记一台电脑的一串数字，比如`192.168.1.1`，在本地局域网上是唯一的。

`IP`地址的分类：`A类`， `B类`， `C类`， `D类`， `E类`。

每一个`IP`地址包括两部分：**网络地址**和**主机地址**


![clipboard.png](/img/bV5nsH)


**A类IP地址**
第一个字节不变（网络号不变），其它字节可以变化（主机号可变）。
一个A类`IP`地址：1字节的网络地址 + 3字节主机地址组成, 网络地址的最高位必须是“0”

地址范围：`1.0.0.1` - `126.255.255.254`
二进制表示为：`00000001 00000000 00000000 00000001` - `01111110 11111111 11111111 11111110`
A类的可用网络有126个，每个网络能容纳1677214个主机

**B类IP地址**
第一个字节和第二个字节不变（网络号不变），其它字节可以变化（主机号可变）。
一个B类`IP`地址：2个字节的网络地址 + 2个字节的主机地址组成，网络地址的最高位必须是“10”

地址范围：`128.1.0.1` - `191.255.255.254`
二进制表示为：`10000000 00000001 00000000 00000001` - `10111111 11111111 11111111 11111110`
可用的B类网络有16384个，每个网络能容纳65534主机

**C类IP地址**
第一个字节和第二个字节不变,第三个字节（网络号不变），其它字节可以变化（主机号可变）
一个C类`IP`地址：3个字节的网络地址 + 1个字节的主机地址组成，网络地址最高为必须是“110”

地址范围：`192.0.1.1` - `233.255.255.254`
二进制表示为：`11000000 00000000 00000001 00000001` - `11011111 11111111 11111110 11111110`
C类网络可达2097152个，每个网络能容纳254个主机

**D类地址**
D类地址用于多点广播

D类`IP`地址第一个字节以`1110`开始，它是一个专门保留的地址。
它并不指向特定的网络，目前这一类地址被用在多点广播（Multicast）中
多点广播地址用来一次寻址一组计算机

地址范围：`224.0.0.1` - `239.255.255.254`

**E类IP地址**
以`1111`开始，为将来使用保留
E类地址保留，仅作实验和开发用


**私有IP**

国际规定有一部分`IP`地址是在局域网中使用，属于私网`IP`，不在公网中使用

```
10.0.0.0 - 10.255.255.255
172.16.0.0 - 172.31.255.255
192.168.0.0 - 192.168.255.255
```

Note:
相同网段:`192.168.1`前面3个字节相同就称之相同网段,即网络号不变就是相同网段

`IP`地址范围：`127.0.0.1` - `127.255.255.255`用于回路测试


## socket

`socket套接字`作用：多台电脑间进程的通信

```
socket.socket(AddressFamily, Type)
```
`Address Family`: 可以选择`AF_INET`（用于Internet进程间通信）或者`AF_UNIX`（用于同一台机器进程间通信），一般使用`AF_INET`
`Type`:套接字类型，可以是`SOCK_STREAM`（流式套接字，主要用于TCP协议）;也可以是`SOCK_DGRAM`(数据报套接字，主要用于UDP协议)

`TCP`通信：
```
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
```
`UDP`通信：
```
import socket
s = socket.socket(socket.AF_INIT, socket.SOCK_DGRAM)
```

`TCP`通信好处：不会丢失数据，数据可靠。
`TCP`通信坏处：速度慢。

> UDP

`UDP`用户数据报协议，是一个无连接的简单的面向数据报的运输层协议。`UDP`不提供可靠性，它只把应用程序传递`IP`曾的数据报发出去，但是并不能保证数据达到目的地。
由于`UDP`在传输数据报前不用在客户和服务端之间建立一个连接，且没有超时重发等机制，故而传输速度很快。

`UDP`是一种面向无连接的协议，每个数据报都是一个独立的信息，包括完整的源地址或目的地址，它在网络上以任何可能的路径传往目的地，因此是否能达到目的地，到达目的地的地址以及内容的正确性都是不能保证的。


`UDP`特点：

- `UDP`是面向无连接的通讯协议，`UDP`数据报括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。
- `UDP`传输数据时有大小限制，每个被传输的数据报必须限定在64KB之内。
- `UDP`是一个不可靠的协议，发送方所发送的数据报并不一定以相同的次序到达接收方。

`UDP`一般用于**多点通信**和**实时的数据业务**:

- 语音广播
- 视频
- QQ
- TFTP(简单文件传送）
- SNMP（简单网络管理协议）
- RIP（路由信息协议，如报告股票市场，航空信息）
- DNS(域名解释）

> `UDP`发送数据

1. 创建客户端套接字
2. 发送/接收数据
3. 关闭套接字

```
from socket import *


udpSocekt = socket(AF_INET, SOCK_DGRAM)

udpSocket.send(b'msg', '192.168.1.201', 8081)

udpSocket.close()
```

> `UDP`发送、接收数据

```
# coding=utf-8

from socket import *


udpSocket = socket(AF_INET, SOCK_DGRAM)
sendAddr = ('192.168.1.201', 8080)
sendData = raw_input("请输入要发送的数据:")
udpSocket.sendto(sendData, sendAddr)

recvData = udpSocket.recvfrom(1024) # 1024表示本次接收的最大字节数

print(recvData)

# 关闭套接字
udpSocket.close()
```

> 端口问题

运行程序端口号会变化：
每重新运行一次网络程序，端口不一样的原因：数字标识这个网络程序，当重新运行时，如果没有确定到底用哪个，系统默认会随机分配。
这个网络程序在运行的过程中，这个就唯一标识这个程序，所以如果其它电脑上的网络程序如果想要向此程序发送数据，那么就需要向这个数字(即端口)标识的程序发送。

在同一个OS中，端口不允许相同，即如果某个端口已经被使用了，那么在这个端口进程释放该端口之前，其它进程不能使用该端口。


> 绑定信息

一般情况下，一天电脑上运行的网络程序有很多，而各自用端口号很多情况下，为了不育其它的网络程序占用同一个端口好，往往在编程中，`udp`的端口号一般不绑定。

`bind`作用：固定端口和`IP`

socket接收信息:
```
# coding=utf-8

from socket import *


udpSocket = socket(AF_INET, SOCK_DGRAM)
bindAddr = ('', 9001) # ip地址和端口号，ip一般不用写，表示本机的任何一个ip
udpSocket.bind(bindAddr) # 绑定ip和端口号

recvData = udpSocket.recvfrom(1024) # 1024表示本次接收的最大字节数

udpSocket.close()
```

一个`udp`网络程序，可以不绑定，此时操作系统会随机进行分配一个端口，如果重新运行次程序端口可能会发生变化
一个`udp`网络程序，也可以绑定信息（ip地址，端口号），如果绑定成功，那么操作系统用这个端口号来进行区别收到的网络数据是否是此进程的

发送方不需要绑定信息，服务方（接收方）需要绑定信息。
接收和发送，可以同时进行。

网络通信中的工作方式：
- 单工：只能往一个方向发送数据。例如（收音机）
- 半双工：一方在传输，另一方无法进行其它操作，同一时刻，只能执行一方。例如（对讲机）
- 全双工: 二个方向可以同时传输数据。例如（电话）

网络套接字（UDP和TCP）是**全双工**,例如（下载的同时，可以同时上传）


> Python3编码问题

在`socket.sendto()`时`Python3`默认需要字节一样的对象。不能使用`str`类型传递。

发送数据时的解决方法：
```
sendData = 'msg'
# udpSocket.sendto(sendData.encode('utf-8'), (ip, prot))
udpSocket.sendto(sendData.encode('gb2312'), (ip, prot))
```
接收数据时的解决方法：
```
recvData =udpSocket.recvfrom(1024)

content, destInfo = recvData

print('content is %s'%content.decode('gb2312')) # decode() 默认是utf-8
```

> UDP网络通信过程


![clipboard.png](/img/bV5xib)

> echo服务器

echo(回显)服务器: 发送一条数据，返回一条数据。

```
# coding=utf-8

from socket import *


udpSocket = socket(AF_INET, SOCK_DGRAM)

bindAddr = ('', 9001)
udpSocket.bind(bindAddr)

num = 1
while True:
recvData = udpSocket.recvfrom(1024)
udpSocket.sendto(recvData[0], recvData[1]) # 将接收到的数据再发送给对方
print('已经将接收到的第%d个数据返回给对方,内容为:%s'%(num, recvData[0]))
num += 1

udpSocket.close()
```

## tftp文件下载器

`wireshark`流经电脑中的数据，都可以检测到。

`cs架构`：`client`, `server`
`bs架构`：`browser`, `server`

> TFTP协议

TFTP（Trivial File Transfer Protocol,简单文件传输协议）

是`TCP/IP`协议族中的一个用来在客户端与服务器之间进行**简单文件传输**的协议


特点：
- 简单
- 占用资源小
- 适合传递小文件
- 适合在局域网进行传递
- 端口号为`69`
- 基于`UDP`实现

`TFTP`下载过程：

`TFTP`服务器默认监听`69`号端口
当客户端发送"下载"请求（即读请求）时，需要向服务器的`69`端口发送，服务器若批准此请求，则使用一个新的，临时的，端口进行数据传输。

![clipboard.png](/img/bV5zVT)

`TFTP`数据包的格式：

![clipboard.png](/img/bV5z3H)

确认包`ACK`都需要往随机端口发送数据.
上传和下载往`69`端口发送数据.

`TFTP`操作码：

| 操作码 | 功能 |
|: --- :|: --- :|
|1  |读请求，即下载|
|2    |写请求，即上传|
|3    |表示数据包，即DATA|
|4    |确认码，即ACK|
|5    |错误|

`pack`和`unpack`的使用:

如何知道服务器发送完毕？
标记数据发送完毕：规定当客户端接收到到数据小于`516`字节（2字节操作码 + 2个字节到序号 + 512字节数据）时，意味着服务器发送完毕。

保证一个数字占用2个字节？
使用`struct.pack()`
```
sendData = struct.pack("!H8sb5sb",1,"test.jpg",0,"octet",0) # !表示网络数据， H占2个字节，8S占8个字节，b占一个字节。
```

大端：在CPU中高位存储低位，CPU中低位存储高位
小端：在CPU中低位存储低位，CPU中高位存储高位



